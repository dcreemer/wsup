#! /usr/bin/env bash
#
# WSUP -- Workspace Set UP
#
# assumes sudo, bash, and curl
# 

set -o nounset

##
## globals
##

# operating system name
OS=`uname -s`

# the WSUP directory
WD="$HOME/.wsup"

# default URL prefix for repos:
REPO_PREFIX="https://github.com/${USER}"

# files to ignore
IGNORE_RE="(\.git)|(\.gitignore)|(\.wsup)|([Rr][Ee][Aa][Dd][Mm][Ee].*)|(LICENSE)"

# default repo suffix for 'base' repository
BASE_TARGET="dotfiles"

# the "map" of target => git repos URLs
REPOS=("...x... __ ...x...")

# the repository on which we are currently operating
REPO=""

# verbosity level; 0==debug, 1 == normal
VERBOSE=1

# current command
CMD=""

# list of all legal commands
commands="help add list link unlink verify wsup"

# final error code
ERR=0

##
## logging
##

log()
{
    local lvl=$1
    local targ=$2
    shift 2
    local msg=$*
    if [[ "$lvl" -ge "$VERBOSE" ]]; then
        if [[ "$targ" == "" ]]; then
            targ="----------------"
        fi
        printf "[%16s] %s\n" "$targ" "$msg"
    fi
}

seterr()
{
    local code=$1
    if [[ $ERR -eq 0 ]]; then
        ERR=$code
    fi
}

##
## read configs
##

read_configs()
{
    if [[ -r "$HOME/.wsup/config" ]]; then
        log 0 "" "reading $HOME/.wsup/config"
        . "$HOME/.wsup/config"
    fi
    local targs=$(/bin/ls -A ${WD})
    for t in $targs; do
        local tc="${WD}/${t}/.wsup/config"
        if [[ -r "$tc" ]]; then
            log 0 "" "reading ${tc}"
            . "$tc"
        fi
    done
}

##
## target / management
##

add_target()
{
    # add k = v to REPOS map
    local k=$1
    local v=$2
    REPOS[${#REPOS[@]}]="${k} __ ${v}"
    log 0 "$k" "adding target $v"
}

get_target()
{
    # given a target name, fetch the target repo
    local target=$1
    REPO=""
    for pair in "${REPOS[@]}" ; do
        if [[ $target == "${pair%% __ *}" ]]; then
            REPO="${pair##* __ }"
        fi
    done
}

scan_targets()
{
    # look for targets on disk but not pre-added to the targets list
    for t in $(/bin/ls -A ${WD}); do
        local tc="${WD}/${t}/"
        if [[ -d "$tc" ]]; then
            get_target $t
            if [[ "$REPO" == "" ]]; then
                # found a target -- get the remote (if any)
                if [[ -d "${tc}/.git" ]]; then
                    repo=`cd ${tc}; git remote -v | grep fetch | awk '{print $2}'`
                else
                    repo=""
                fi
                add_target $t "$repo"
            fi
        fi
    done
    # if there is no base repo, add the default:
    get_target "base"
    if [[ $REPO == "" ]]; then
        add_target "base" "${REPO_PREFIX}/${BASE_TARGET}"
        get_target "base"
    fi
}


map_targets()
{
    local fn=$1
    shift
    for pair in "${REPOS[@]}" ; do
        local t="${pair%% __ *}"
        if [[ "$t" != "...x..." ]]; then
            $fn "$t" "$*"
        fi
    done
}

##
## pkg managment
##

install_package()
{
    local pkg=$1
    case $OS in
        "Linux")
            install_apt_pkg $pkg
            ;;
        "Darwin")
            install_brew_pkg $pkg
            ;;
        "FreeBSD")
            install_bsd_pkg $pkg
            ;;
    esac
}

install_apt_pkg()
{
    # install an apt-based package (if it doesn't exist)
    local p=$1
    dpkg -l $p >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "[INSTALL] $p"
        sudo apt-get install -y $p
    fi
}

install_brew_pkg()
{
    # install a brew-based package (if it doesn't exist)
    local p=$1
    if [ ! -d /usr/local/Cellar/${p} ]; then
        echo "[INSTALL] $p"
        brew install $p
    fi
}

install_bsd_pkg()
{
    # install a freebsd pkg-based package (if it doesn't exist)
    local p=$1
    pkg info -e $p
    if [ $? -eq 1 ]; then
        echo "[INSTALL] $p"
        sudo pkg install -U -y $p
    fi
}

##
## repos
##

fetch_repo()
{
    # given a target name, fetch the repository 
    local target=$1
    local target_dir=${WD}/$target
    if [[ ! -r $target_dir ]]; then
        get_target $target
        if [[ "$REPO" != "" ]]; then
            log 1 "$target" "cloning $REPO"
            git clone $REPO $target_dir
        else
            log 1 "$target" "target unknown"
            seterr -1
        fi
    fi
}

##
## linking files into place
##

link_target()
{
    local target=$1
    link_dir $target "${WD}/$target" "$HOME" 1
    local osdir="${WD}/$target/.wsup/${OS}"
    if [[ -e "$osdir" && -d "$osdir" ]]; then
        link_dir $target "$osdir" "$HOME" 1
    fi
}

link_dir()
{
    # link all of the files in the target directory to $HOME. Regular files are linked directly,
    # directories files are first made in the home directory, then linked from within
    local target=$1
    local source_dir=$2
    local dest_dir=$3
    local recur=$4
    local files=$(/bin/ls -A ${source_dir})
    if [[ ! -d "${dest_dir}" ]]; then
        log 0 "" "mkdir $dest_dir"
        mkdir -p "${dest_dir}"
    fi
    for src_f in $files; do
        if [[ ! "$src_f" =~ $IGNORE_RE ]]; then
            if [[ -d "${source_dir}/${src_f}" && $recur -eq 1 ]]; then
                link_dir $target "${source_dir}/${src_f}" "${dest_dir}/${src_f}" 0
            else
                symlink $target "${source_dir}/${src_f}" "${dest_dir}/${src_f}"
            fi
        fi
    done
}
 
symlink()
{
    target=$1
    src=$2
    targ=$3
    log 0 "$target" "link $targ -> $src"
    # if we have a good source, target
    if [ ! -z "$src" ] && [ ! -z "$targ" ]; then
        if [ ! -h $targ ]; then
            # if it's not a symlink already...
            if [ -r $targ ]; then
                # but is there, then remove it
                rm -rf $targ
            fi
            # and symlink it
            log 1 "$target" "link $src"
            ln -s $src $targ
        fi
    fi
}

##
## installation
##

run_postinstall()
{
    # if target has a postinstall script, run it
    local script="${WD}/$1/.wsup/postinstall"
    if [[ -x "$script" ]]; then
        log 1 $1 "exec $script"
        $script
    fi
}

##
## top-level commands
##

execute_command()
{
    local cmd=$1
    shift
    if [[ $commands =~ $cmd ]]; then
        command_$cmd $@
    else
        echo "command \"$cmd\" unknown"
        command_help
        seterr -1
    fi
}

##
## add command -- fetch the named target and then link
##

command_add()
{
    local target=$1
    log 1 $target "start add"
    fetch_repo $target
    link_target $target
    run_postinstall $target
    log 1 $target "end add"
}

##
## unlink command -- remove the links from the given target (but do not remove the target)
##

command_unlink()
{
    local target=$1
    log 1 $target "start unlink"
    log 0 $target "unlink <tbd>"
    log 1 $target "end unlink"
}

##
## link command -- link all files and dirs in the given target(s)
##

command_link()
{
    if [[ $# -gt 0 ]]; then
        for t in $@; do
            link_one $t
        done
    else
        map_targets link_one "noerr"
    fi
}

link_one()
{
    local target=$1
    shift
    local noerr=$*
    if [[ -d "${WD}/${target}" ]]; then
        link_target $target
        run_postinstall $target
    elif [[ "$noerr" == "" ]]; then
        log 1 $target "unknown"
        seterr -1
    fi
}

##
## verify command -- check to ensure all known targets are install correctly
##

command_verify()
{
    if [[ $# -gt 0 ]]; then
        for t in $@; do
            verify_one $t
        done
    else
        map_targets verify_one
    fi
}

verify_one()
{
    local target=$1
    if [[ -d "${WD}/${target}" ]]; then
        log 1 $target "verify"
    else
        log 1 $target "not installed"
    fi
}

##
## list command -- list all known targets, both installed and not
##

command_list()
{
    echo "TARGET           I REPOSITORY"
    echo "---------------- - --------------------------------------------------------------------"
    map_targets "print_target_info"
}

print_target_info()
{
    local target=$1
    get_target $target
    local r="$REPO"
    local installed=" "
    if [[ -d "${WD}/${target}" ]]; then
        installed="*"
    fi
    if [[ "$r" == "" ]]; then
        r="<unknown>"
    fi
    printf "%-16s %s %s\n" "${target}" "$installed" "$r"
}

##
## wsup
##

command_wsup()
{
    log 0 "" "wsup <tbd>"
}

command_help()
{
    echo ""
    echo "this is the help"
    echo ""
}

##
## Main Program
##

# parse command line options
while getopts "v" opt; do
    case $opt in
        v)
            VERBOSE=0
            ;;
        *)
            command_help
            exit -1
            ;;
    esac
done
shift $((OPTIND - 1))

# parse command argument
if [[ $# == 0 ]]; then
    CMD="verify"
else
    CMD=$1
    shift
fi

# read in all configuration files
read_configs

# scan to be sure we have all known targets
scan_targets

# execute the given command and return status:
execute_command $CMD $@
if [[ $ERR -ne 0 ]]; then
    exit $ERR
fi
